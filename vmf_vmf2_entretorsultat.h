////////////////////////////////////////////////////////////////////////
//
// vmf_vmf2_entretorsultat.h
//
// This file was generated by MapForce 2023r2.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

#ifndef vmf_vmf2_entretorsultat_H_INCLUDED
#define vmf_vmf2_entretorsultat_H_INCLUDED

#pragma once

#include "../Altova/AltovaMapforce.h"

#include "../AltovaXML/Node.h"
#include "../AltovaXML/MFNodeAdapters_DOM.h"
#include "../AltovaXML/InternalXML.h"
#include "../AltovaDB/AltovaDB.h"
namespace vmf 
{
class vmf2_entretorsultat
{
	class Main : public altova::mapforce::Enumerable
	{
	public:
		string_type var1_entr_e;
	
		Main(const string_type& a_var1_entr_e) : altova::mapforce::Enumerable(), var1_entr_e(a_var1_entr_e) {}

		~Main()	
		{
		}

		altova::mapforce::Enumerator* GetEnumerator() {return new altova::mapforce::MFEmptySequence::Enum(this);}
	};

public:
	vmf2_entretorsultat();
	typedef std::map< string_type, string_type > hash_type;
	hash_type hash;


	// global function in library namespace

	static altova::mapforce::IEnumerable Create(string_type var1_entr_e)
	{
		vmf2_entretorsultat vmf;
		vmf2_entretorsultat::hash_type::iterator it = vmf.hash.find(var1_entr_e);
		if (it != vmf.hash.end())
			return altova::Core::Box((*it).second);
		else
			return altova::mapforce::MFEmptySequence::Instance();
	}

	static altova::mapforce::IEnumerable Eval(string_type var1_entr_e)
	{

		return Create(var1_entr_e);
	
	}

};
}	// namespace vmf


#endif // vmf_vmf2_entretorsultat_H_INCLUDED
